# Emulating SSL and Password Verification
Cybersecurity Project 

Emulated SSL cryptographic protocols and password verification using a SHA-2 hashing algorithm and randomly generated 32-character hexadecimal salt for increased security, with RSA and AES encryption for private and public keys to create an encrypted interaction between client and server that is completely confidential and has complete integrity

## Password Hashing
For hashing the password in the file, we imported hashlib and used a SHA-2 hashing algorithm which is a form of secure hashing algorithm developed by the United States National Security Agency. We decided on this hashing algorithm as it provides great security against collision attacks while still having good performance. For salting we generated a random uuid.hex with the help of the uuid library. This provides us with a 32-character hexadecimal string that we then append to the password before hashing the result. This greatly increases our security against precomputed dictionary attacks. 

## Public & Private Key Usage
Our private key and public key pair were generated using openssl with a bit size of 1024. The following command allowed us to generate the private key with RSA encryption:
openssl genrsa -out rsa.private 1024

Next, to generate our public key. We run the following command:
openssl rsa -in rsa.private -out rsa.public -pubout -outform PEM

This leaves us with a private / public key pair using RSA encryption. Our keys were stored in a folder titled “TheKeys.” We imported AES from Crypto.Cipher to encrypt the messages with Cipher-Block Chaining. This Cipher-Block Chaining forces us to use an initialization vector, so we randomly picked one. This ciphertext method depends on all previous plaintext blocks and the current as well. AES allows us to encrypt with a mode of operation which provides security for the messages between the server and client. 

1. By typing: `ssh-keygen -t rsa` into Terminal can generate RSA keys.

2. After the execution in the Terminal, I get Keys & Keys.pub where Keys is the private key and Keys.pub holds the public key in a different format.

3. Then I used: `ssh-keygen -e -m PEM -f Keys.pub > Pubkeys.pub` to generate the public key in the same format as the Key (private key) Opening the files will make more sense than my description

4. `passfile.txt` was generated by executing the `add_user.py` function I finished.

## Symmetric Encryption
In order to manage symmetric encryption, we used the Advanced Encryption Standard (AES) which is an iterative block cipher. Encrypting converts the data into ciphertext and decrypting converts the data back into plaintext. This encryption mode was chosen because its operational time is fast and compact on a variety of platforms, the most secure, and it can resist most, if not all, attacks. For this encryption mode we did have to trade off a higher memory in comparison to RC5 and energy consumption in comparison to other block cipher encryption algorithms.  



## Eavesdroppers 
Eavesdropper is a network layer attack focusing on capturing small packets from the network transmitted by computers and searching the content for information. If a network service was lacking encryption, it would be likely for the eavesdropping attack to occur. However, in the program we built, all of our messages were encrypted by various methods. For example, in the beginning, we generated random values for salting. Then we generated the private key using RSA encryption. Those methods will prevent other parties from being able to decode or eavesdrop what was sent.

## Replay Attacks
The program is secure from replay attacks because both the sender and receiver have a completely random established session key. Since it is encrypted, the keys cannot be decoded at the end of the transmission. Additionally, there is a function which verifies that the user has been authenticated before encrypting a response to the client. 
